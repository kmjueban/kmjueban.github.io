## 消息中间件


#### 简介

* 消息中间件也可以称为消息队列，指高效可靠的消息传递机制进行与平台无关的数据交流

* 当下主流的消息中间件有Kafka、ActiveMQ、RocketMQ、RabbitMQ，不管选择其中的哪一款，都会有用的不趁手的地方，毕竟不是为你量身定制的

* 优点：在客户端与服务端之间进行同步和异步的连接，并且任何时候都能将消息进行传送和转发，主要用来解决应用耦合，削峰，异步通信

#### 作用

* 解耦

* 削峰

* 异步通信

* 顺序保证

* 缓冲

* 冗余(存储)

* 扩展性

* 可恢复性

#### 消息中间件的两种模式

* 队列和发布模式

  队列和发布模式包含三个角色：消息队列（Queue）、发送者(Sender)、接收者(Receiver)，每个消息都被发送到一个特定的队列，接收者从队列中获取消息，一组消费者从服务器读取消息一个消息只能有一个消费者来消费

* 队列和发布的特点：

  每个消息只有一个消费者（Consumer），即一旦被消费，消息就不再在消息队列中

  发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行它不会影响到消息被发送到队列

  接收者在成功接收消息之后需向队列应答成功

  每个消息都会被成功处理

* 订阅模式（Pub/Sub）模式

  订阅模式包含三个角色：主题（Topic）、发布者（Publisher）、订阅者（Subscriber）多个发布者将消息发送到Topic，系统将这些消息传递给多个订阅者

* 订阅模式的特点：

  每个消息可以有多个消费者

  发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息

  为了消费消息，订阅者必须保持运行的状态

  发送的消息可以不被做任何处理、或者只被一个消息者处理、或者可以被多个消费者处理

#### 常用中间件介绍与对比

* Kafka

  Kafka是LinkedIn开源的分布式发布-订阅且基于 ZooKeeper 协调的分布式消息系统，目前归属于Apache顶级项目。Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务

* RabbitMQ

  RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次，
  RabbitMQ比Kafka可靠，Kafka更适合IO高吞吐的处理，一般应用在大数据日志处理或对实时性（少量延迟），可靠性（少量丢数据）要求稍低的场景使用，比如ELK日志收集

* ZeroMQ

  号称史上最快的消息队列，基于 C 语言开发。ZeroMQ 是一个消息处理队列库，可在多线程、多内核和主机之间弹性伸缩
  
  ZeroMQ 本身就不是一个消息队列服务器，更像是一组底层网络通讯库，对原有的 Socket API 上加上一层封装

* RocketMQ

  RocketMQ是阿里开源的消息中间件，它是纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ思路起源于Kafka，但并不是Kafka的一个Copy，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog分发等场景

  
  
* ActiveMQ

  Apache 出品的、采用 Java 语言编写的完全基于 JMS1.1 规范的面向消息的中间件，为应用程序提供高效的、可扩展的、稳定的和安全的企业级消息通信，其最新架构被命名为Apollo
  
#### 消息中间件选型

* 优先级队列

  优先级队列不同于先进先出队列，优先级高的消息具备优先被消费的特权，这样可以为下游提供不同消息级别的保证
  
  不过这个优先级也是需要有一个前提的：
  
  如果消费者的消费速度大于生产者的速度，并且消息中间件服务器(一般简单的称之为 Broker)中没有消息堆积，那么对于发送的消息设置优先级也就没有什么实质性的意义了，因为生产者刚发送完一条消息就被消费者消费了，那么就相当于 Broker 中至多只有一条消息，对于单条消息来说优先级是没有什么意义的

* 延迟队列

  “三十分钟之内未付款，订单自动取消”，这个是延迟队列的一种典型应用场景，延迟队列存储的是对应的延迟消息，所谓“延迟消息”是指当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费
  
  延迟队列一般分为两种：
  
  基于消息的延迟，是指为每条消息设置不同的延迟时间，那么每当队列中有新消息进入的时候就会重新根据延迟时间排序，缺点是会对性能造成极大的影响

  基于队列的延迟，实际应用中大多采用这种，设置不同延迟级别的队列，比如5s、10s、30s、1min、5mins、10mins等，每个队列中消息的延迟时间都是相同的，这样免去了延迟排序所要承受的性能之苦，通过一定的扫描策略(比如定时)即可投递超时的消息

* 死信队列
  
  死信队列:由于某些原因消息无法被正确投递，为了确保消息不会被无故丢弃，一般将其置于一个特殊角色的队列，这个队列称为死信队列
  
  对应的还有一个“回退队列”的概念，如果消费者在消费时发生了异常，那么就不会对这一次消费进行确认(Ack)， 进而发生回滚消息的操作之后消息始终会放在队列的顶部，然后不断被处理和回滚，导致队列陷入死循环。为了解决这个问题，可以为每个队列设置一个回退队列，它和死信队列都是为异常的处理提供的一种机制保障。实际情况下，回退队列的角色可以由死信队列和重试队列来扮演
  

* 重试队列

  看成是一种回退队列，具体指消费端消费消息失败时，为防止消息无故丢失而重新将消息回滚到 Broker 中
  
  与回退队列不同的是重试队列一般分成多个重试等级，每个重试等级一般也会设置重新投递延时，重试次数越多投递延时就越大
  
  举个例子：消息第一次消费失败入重试队列 Q1，Q1 的重新投递延迟为 5s，在 5s 过后重新投递该消息，如果消息再次消费失败则入重试队列 Q2，Q2 的重新投递延迟为 10s，在 10s 过后再次投递该消息。

  以此类推，重试越多次重新投递的时间就越久，为此需要设置一个上限，超过投递次数就入死信队列

  重试队列与延迟队列有相同的地方，都是需要设置延迟级别，它们彼此的区别是：延迟队列动作由内部触发，重试队列动作由外部消费端触发;延迟队列作用一次，而重试队列的作用范围会向后传递

* 消费模式

  消费模式分为推(push)模式和拉(pull)模式：

  推模式，是指由 Broker 主动推送消息至消费端，实时性较好，不过需要一定的流制机制来确保服务端推送过来的消息不会压垮消费端

  拉模式，是指消费端主动向 Broker 端请求拉取(一般是定时或者定量)消息，实时性较推模式差，但是可以根据自身的处理能力而控制拉取的消息量

* 广播消费

  RabbitMQ 是一种典型的点对点模式，而 Kafka 是一种典型的发布订阅模式

  但是 RabbitMQ 中可以通过设置交换器类型来实现发布订阅模式而达到广播消费的效果，Kafka 中也能以点对点的形式消费，你完全可以把其消费组(Consumer Group)的概念看成是队列的概念

* 消息回溯

  一般消息在消费完成之后就被处理了，之后再也不能消费到该条消息。消息回溯正好相反，是指消息在消费完成之后，还能消费到之前被消费掉的消息

  对于消息而言，经常面临的问题是“消息丢失”，至于是真正由于消息中间件的缺陷丢失还是由于使用方的误用而丢失，一般很难追查，如果消息中间件本身具备消息回溯功能的话，可以通过回溯消费复现“丢失的”消息进而查出问题的源头所在

* 消息堆积+持久化

  流量削峰是消息中间件的一个非常重要的功能，而这个功能其实得益于其消息堆积能力

  消息堆积分内存式堆积和磁盘式堆积：
  
  RabbitMQ 是典型的内存式堆积，但这并非绝对，在某些条件触发后会有换页动作来将内存中的消息换页到磁盘(换页动作会影响吞吐)，或者直接使用惰性队列来将消息直接持久化至磁盘中

  Kafka 是一种典型的磁盘式堆积，所有的消息都存储在磁盘中

  从另外一个角度讲，消息堆积也为消息中间件提供了冗余存储的功能

* 消息过滤

  消息过滤是指按照既定的过滤规则为下游用户提供指定类别的消息
  
  以 Kafka 而言，完全可以将不同类别的消息发送至不同的 Topic 中，由此可以实现某种意义的消息过滤
  
  Kafka 还可以根据分区对同一个 Topic 中的消息进行分类，不过，更加严格意义上的消息过滤，应该是对既定的消息采取一定的方式按照一定的过滤规则进行过滤
  
  以 Kafka 为例，可以通过客户端提供的 Consumer Interceptor 接口或者 Kafka Stream 的 Filter 功能进行消息过滤

* 跨语言支持

  技术栈体系中会有多种编程语言，如 C/C++、Java、Go、PHP 等，消息中间件本身具备应用解耦的特性，如果能够进一步的支持多客户端语言，那么就可以将此特性的效能扩大

  跨语言的支持力度也从侧面反映出一个消息中间件的流行程度


* 消息顺序性

  指保证消息有序。这个功能有个很常见的应用场景就是 CDC(Change Data Chapture)

  以 MySQL 为例，如果其传输的 Binlog 的顺序出错，比如原本是先对一条数据加 1，然后再乘以 2，发送错序之后就变成了先乘以 2 后加 1，造成数据不一致


* 安全机制

  在 Kafka 0.9 版本之后就开始增加了身份认证和权限控制两种安全机制：

  身份认证，是指客户端与服务端连接进行身份认证，包括客户端与 Broker 之间、Broker 与 Broker 之间、Broker 与 ZooKeeper 之间的连接认证，目前支持 SSL、SASL 等认证机制

  权限控制，是指对客户端的读写操作进行权限控制，包括对消息或 Kafka 集群操作权限控制。权限控制是可插拔的，并支持与外部的授权服务进行集成

  对于 RabbitMQ 而言，其同样提供身份认证(TLS/SSL、SASL)和权限控制(读写操作)的安全机制

* 消息幂等性

  确保消息在生产者和消费者之间进行传输，一般有三种传输保障(Delivery Guarantee)：

  At most once，至多一次，消息可能丢失，但绝不会重复传输

  At least once，至少一次，消息绝不会丢，但是可能会重复

  Exactly once，精确一次，每条消息肯定会被传输一次且仅一次

  Kafka 自 0.11 版本开始引入了幂等性和事务，Kafka 的幂等性是指单个生产者对于单分区单会话的幂等

* 事务性消息

  事务本身是一个并不陌生的词汇，事务是由事务开始(Begin Transaction)和事务结束(End Transaction)之间执行的全体操作组成。

  支持事务的消息中间件并不在少数，Kafka 和 RabbitMQ 都支持，不过此两者的事务是指生产者发生消息的事务，要么发送成功，要么发送失败

* 性能

  消息中间件的性能一般是指其吞吐量。虽然从功能维度上来说，RabbitMQ 的优势要大于 Kafka，但是 Kafka 的吞吐量要比 RabbitMQ 高出 1 至 2 个数量级

  一般 RabbitMQ 的单机 QPS 在万级别之内，而 Kafka 的单机 QPS 可以维持在十万级别，甚至可以达到百万级

* 可靠性+可用性

  消息丢失是使用消息中间件时所不得不面对的一个痛点，其背后消息可靠性也是衡量消息中间件好坏的一个关键因素

  然而说到可靠性必然要说到可用性，注意这两者之间的区别：

  消息中间件的可靠性是指对消息不丢失的保障程度

  消息中间件的可用性是指无故障运行的时间百分比，通常用几个 9 来衡量