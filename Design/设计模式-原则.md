## 设计模式原则-单一职责（SRP）

* 单一职责原则英文名Single Responsibility Principle 简称SRP

* 单一职责原则的定义是：有且仅有一个原因引起类的变更

* 举例：

~~~
public interface IUserInfo{
	void setUserID(String userId);
	String getUserID();
	void setUserName(String userName);
	String getUserName();
	boolean addUserRole(int RoleId);
}
~~~
从上面的例子可以看出 引起用户信息类的变更条件除了用户信息属性外还有用户角色的方法可以引起类的变更明显不符合单一职责原则

* 单一职责的好处：
	
	1. 类的复杂性降低实现什么职责都有清晰明确的定义

	2. 可读性提高复杂性降低

	3. 可维护性提高

	4. 变更引起的风险降低


## 设计模式原则-里氏替换原则（LSP）

* 里氏替换原则的定义为：只要父类能出现的地方子类也可以出现并且替换为子类不会产生任何的错误和异常 ，反过来不行

~~~
public class Father{
	public Collection do(Map map){
		System.out.println("father");
	}
}

public class Son extends Father{
	public Collection do(HashMap hashMap){
		System.out.println("son");
	}
}

public class Client{
	public static void main(String[] args){
		//有父类的地方就有子类
		Father father = new Father();
		//Son son = new Son();
		HashMap hashMap = new HashMap();
		//son.do(hashMap);
		father.do(hashMap);
	}
}
~~~

优点：

	1. 提高代码重用性
	2. 提高代码可扩展性

缺点：

	1. 继承具有侵入性
	2. 增加耦合


## 设计模式原则-依赖倒置原则（DIP）

* 依赖倒置原则定义为：高层模块不应该依赖于低层模块，抽象不应该依赖细节，细节应该依赖抽象

* 举例（罪犯拿手枪射击）

~~~
class Pistol {
    public void fire(){
        System.out.println("手枪开火");
    }
}

class Criminal{

    public void shoot(Pistol pistol){
        pistol.fire();
    }
}

class Client{
    public static void main(String[] args) {
        Pistol pistol = new Pistol();
        Criminal criminal = new Criminal();
        criminal.shoot(pistol);
    }
}
~~~

上述代码讲述罪犯拿手枪射击的例子，是没有问题的，但如果枪不是手枪类型那么罪犯就没有办法开枪了，所以我们需要采用依赖倒置原则，让细节依赖抽象

~~~
interface Gun{
    void fire();
}

class Pistol implements Gun{
    @Override
    public void fire(){
        System.out.println("手枪开火");
    }
}

class Rifle implements Gun{
    @Override
    public void fire() {
        System.out.println("来福枪开火");
    }
}

interface BadPerson{
    void shoot(Gun gun);
}

class Criminal implements BadPerson{

    @Override
    public void shoot(Gun gun){
        gun.fire();
    }
}

class Client{
    public static void main(String[] args) {
        Gun pistol = new Pistol();
        BadPerson criminal = new Criminal();
        criminal.shoot(pistol);
    }
}
~~~

优点：

1. 减少类间的耦合性，提高系统的稳定性

2. 降低并行开发引起的风险

3. 提高代码的可读性和可维护性



## 设计模式原则-接口隔离原则（ISP）

* 接口隔离原则的定义为：客户端不应该依赖于它不需要的接口

* 举例

~~~
interface INenmo{
    //身材
    void stature();
    //长相
    void face();
    //气质
    void temperament();
}

class Nenmo implements INenmo{

    private String name;

    public Nenmo(String name){
        this.name = name;
    }

    @Override
    public void stature() {
        System.out.println(name + "身材棒");
    }

    @Override
    public void face() {
        System.out.println(name + "长相好");
    }

    @Override
    public void temperament() {
        System.out.println(name + "气质佳");
    }
}

abstract class AConcubine{

    protected INenmo iNenmo;

    public AConcubine(INenmo iNenmo){
        this.iNenmo = iNenmo;
    }

    public abstract void show();
}

class Concubine  extends AConcubine{

    public Concubine(INenmo iNenmo) {
        super(iNenmo);
    }

    @Override
    public void show() {
        super.iNenmo.stature();
        super.iNenmo.face();
        super.iNenmo.temperament();
    }
}

class Client{
    public static void main(String[] args) {
        INenmo xinXin = new Nenmo("xinxin");
        AConcubine concubine = new Concubine(xinXin);
        concubine.show();
    }
}
~~~

选妃的例子已经写完了，但程序还存在很大的问题，我们定义的嫩模类需要具有脸，身材，气质 才有资格被选，而每个人的审美不同，采用接口隔离的原则进行优化

~~~
interface IStatureFace {
    //身材棒
    void stature();

    //长相好
    void face();
}

interface ITemperament {
    //气质佳
    void temperament();
}


class Nenmo implements IStatureFace,ITemperament {

    private String name;

    public Nenmo(String name) {
        this.name = name;
    }

    @Override
    public void stature() {
        System.out.println(name + "身材棒");
    }

    @Override
    public void face() {
        System.out.println(name + "长相好");
    }

    @Override
    public void temperament() {
        System.out.println(name + "气质佳");
    }
}
~~~

这样减轻了嫩模要求的臃肿性 选妃更加灵活


优点：

1. 减少程序的臃肿性

2. 更加灵活

3. 保证接口的纯洁性

缺点：

1. 原子性划分没有界限


## 迪米特法则

* 迪米特法则的定义为：一个对象应该对其他对象有最少的了解

* 