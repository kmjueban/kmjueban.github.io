## IO模型
相信很多人都会有疑问为什么redis是单线程的还能那么快
接下来将会讲解redis单线程处理大量的客户端连接
1. 首先redis的所有数据都是存在内存中 运算起来都是内存级的(注意使用O(n)级别的指令)
2. 非阻塞IO

    * 阻塞IO:应用程序调用IO函数导致应用程序阻塞,等待数据准备好,数据没有准备好将一直等待数据,除非数据准备好或者连接关闭
	举个例子:现在调用read方法要读取x个字节的数据,如果一个字节没有线程就会卡在那里直到凑够x个字节或者关闭连接,而write方法一般不会阻塞,除非内核分配的写缓冲区已满,wirte方法阻塞 等到缓冲区有空间释放
    * 非阻塞IO:当应用程序调用IO函数设定为Non_Blocking后变为非阻塞IO,读写方法不会被阻塞,而是能读多少读多少,能写多少写多少,能读多少取决于内核为套接字分配的读缓冲区内部的数据字节数,能写多少取决于内核为套接字分配的写缓冲区的空闲空间字节数读方法和写方法都会通过返回值来告知程序实际读写了多少字节
3. 多路复用
	
4. 指令队列
5. 响应队列
6. 定时任务
