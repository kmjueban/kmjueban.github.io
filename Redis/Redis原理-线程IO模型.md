## IO模型
相信很多人都会有疑问为什么redis是单线程的还能那么快
接下来将会讲解redis单线程处理大量的客户端连接
1. 首先redis的所有数据都是存在内存中 运算起来都是内存级的(注意使用O(n)级别的指令)
2. 非阻塞IO

    * 阻塞IO:应用程序调用IO函数导致应用程序阻塞,等待数据准备好,数据没有准备好将一直等待数据,除非数据准备好或者连接关闭
	举个例子:现在调用read方法要读取x个字节的数据,如果一个字节没有线程就会卡在那里直到凑够x个字节或者关闭连接,而write方法一般不会阻塞,除非内核分配的写缓冲区已满,wirte方法阻塞 等到缓冲区有空间释放
    * 非阻塞IO:当应用程序调用IO函数设定为Non_Blocking后变为非阻塞IO,读写方法不会被阻塞,而是能读多少读多少,能写多少写多少,能读多少取决于内核为套接字分配的读缓冲区内部的数据字节数,能写多少取决于内核为套接字分配的写缓冲区的空闲空间字节数读方法和写方法都会通过返回值来告知程序实际读写了多少字节

3. 多路复用(事件轮询)

	* 非阻塞IO虽然解决了阻塞问题但是引出了另外一个问题,线程要读数据,读了一半就返回了,不知道什么时候应该继续读,写也一样,如果缓冲区满了没有写完,该如何知道剩下的数据什么时候再写,线程也需要得到通知
	* 多路复用就来解决这个问题,我们使用系统的epoll(linux 相比之前的select性能更加强劲)指令,相当于Java 语言里面的 NIO 技术

4. 指令队列

	* Redis 会将每个客户端套接字都关联一个指令队列,客户端的指令通过队列来排队进行顺序处理,先来先服务

5. 响应队列

	* Redis 同样也会为每个客户端套接字关联一个响应队列 Redis 服务器通过响应队列来将指令的返回结果回复给客户端 如果队列为空，那么意味着连接暂时处于空闲状态,不需要去获取写事件,也就是可以将当前的客户端描述符从write_fds里面移出来 等到队列有数据了,再将描述符放进去 避免epoll系统调用立即返回写事件,结果发现没什么数据可以写 出这种情况的线程会飙高 CPU

6. 定时任务
	
	* 服务器处理要响应 IO 事件外，还要处理其它事情。比如定时任务就是非常重要的一件事。如果线程阻塞在 epoll 系统调用上，定时任务将无法得到准时调度 Redis 的定时任务会记录在一个称为最小堆的数据结构中 这个堆中最快要执行的任务排在堆的最上方 在每个循环周期,Redis 都会将最小堆里面已经到点的任务立即进行处理处理完毕后将最快要执行的任务还需要的时间记录下来,这个时间就是epoll系统调用的timeout参数 因为 Redis 知道未来timeout时间内没有其它定时任务需要处理所以可以安心睡眠timeout的时间
