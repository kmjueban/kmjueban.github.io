## IO模型
相信很多人都会有疑问为什么redis是单线程的还能那么快
接下来将会讲解redis单线程处理大量的客户端连接
1. 首先redis的所有数据都是存在内存中 运算起来都是内存级的(注意使用O(n)级别的指令)
2. 非阻塞IO

    * 阻塞IO:应用程序调用IO函数导致应用程序阻塞,等待数据准备好,数据没有准备好将一直等待数据,除非数据准备好或者连接关闭
	举个例子:现在调用read方法要读取x个字节的数据,如果一个字节没有线程就会卡在那里直到凑够x个字节或者关闭连接,而write方法一般不会阻塞,除非内核分配的写缓冲区已满,wirte方法阻塞 等到缓冲区有空间释放
    * 非阻塞IO:当应用程序调用IO函数设定为Non_Blocking后变为非阻塞IO,读写方法不会被阻塞,而是能读多少读多少,能写多少写多少,能读多少取决于内核为套接字分配的读缓冲区内部的数据字节数,能写多少取决于内核为套接字分配的写缓冲区的空闲空间字节数读方法和写方法都会通过返回值来告知程序实际读写了多少字节

3. 多路复用(事件轮询)

	* 非阻塞IO虽然解决了阻塞问题但是引出了另外一个问题,线程要读数据,读了一半就返回了,不知道什么时候应该继续读,写也一样,如果缓冲区满了没有写完,该如何知道剩下的数据什么时候再写,线程也需要得到通知
	* 多路复用就来解决这个问题,

4. 指令队列

	* Redis 会将每个客户端套接字都关联一个指令队列,客户端的指令通过队列来排队进行顺序处理,先到先服务

5. 响应队列

6. 定时任务
